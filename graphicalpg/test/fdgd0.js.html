<!DOCTYPE html>
<html lang="en-US">
<head><title>fdgd0.js</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

</head>
<body>
<script>var graphdata1 = [
[1, 2, 3, 4, 5, 6, 7, 8, 9],
[0, 10, 27, 28, 30, 31, 73, 104, 105, 108, 109, 110, 111, 112],
[0, 10, 12, 27, 30, 73, 104, 109, 111],
[0, 10, 11, 12],
[0, 10, 28, 30, 31, 73, 104, 109, 111],
[0],
[0, 12, 59, 73, 81, 89, 97, 118, 119, 120],
[0, 11, 12, 59, 73, 81, 89, 97, 118, 119],
[0, 11, 12, 59, 73, 81, 89, 97, 118, 119],
[0, 11, 12, 59, 73, 81, 89, 97, 118, 119],
[1, 2, 3, 4, 57, 58, 77, 86, 88, 104, 113, 114, 115, 116, 117, 118],
[3, 7, 8, 9, 24, 25, 26, 27, 28, 29, 30, 31],
[2, 3, 6, 7, 8, 9],
[14, 15, 16, 17],
[13, 15, 16, 17, 20, 32, 33, 100],
[13, 14, 16, 34, 35, 36, 37, 51],
[13, 14, 15, 32],
[13, 14, 33, 34],
[19, 20, 21, 22, 23],
[18, 21, 96],
[14, 18, 21, 34, 66, 120, 123, 135],
[18, 19, 20, 37, 59, 75, 124, 131, 135],
[18, 93, 94, 95],
[18, 93, 94, 95],
[11, 73, 107],
[11, 73, 107],
[11, 73, 107],
[1, 2, 11],
[1, 4, 11],
[11],
[1, 2, 4, 11],
[1, 4, 11],
[14, 16, 34, 35, 36, 37],
[14, 17, 34, 37, 59, 60, 63, 68, 69, 97, 100, 101, 102, 103],
[15, 17, 20, 32, 33, 100],
[15, 32],
[15, 32, 49, 52, 53, 54, 59, 60],
[15, 21, 32, 33, 54, 60, 63, 65],
[39, 40, 41, 42],
[38, 43, 55, 56, 57, 66],
[38, 43, 57, 66],
[38, 43, 56, 57, 59, 66],
[38, 43, 55, 56, 57, 61, 66, 67],
[39, 40, 41, 42, 44, 45, 46, 47],
[43, 55, 56, 66, 67],
[43, 57, 66, 67],
[43, 55, 61, 67],
[43, 57, 66],
[49, 50],
[36, 48, 51, 52],
[48, 52, 64, 69, 103, 136, 138, 139, 140],
[15, 49, 52, 53, 54],
[36, 49, 50, 51, 53, 60, 68, 69],
[36, 51, 52, 64, 69, 136, 138, 139, 140],
[36, 37, 51, 62, 63, 64, 65],
[39, 42, 44, 46, 56, 57, 58],
[39, 41, 42, 44, 55, 61, 106],
[10, 39, 40, 41, 42, 45, 47, 55, 61, 66, 106, 120, 134],
[10, 55, 61, 66, 134],
[6, 7, 8, 9, 21, 33, 36, 41, 76, 93, 94, 96, 97, 100, 101, 120, 121, 123, 128, 133],
[33, 36, 37, 52, 62, 63, 64, 65],
[42, 46, 56, 57, 58],
[54, 60],
[33, 37, 54, 60, 69, 102, 125, 129, 130],
[50, 53, 54, 60, 65, 129, 130, 140],
[37, 54, 60, 64, 102, 125],
[20, 39, 40, 41, 42, 44, 45, 47, 57, 58, 73, 75, 134],
[42, 44, 45, 46],
[33, 52],
[33, 50, 52, 53, 63, 102, 125],
[71],
[70, 72],
[71],
[1, 2, 4, 6, 7, 8, 9, 24, 25, 26, 66, 74, 75, 76],
[73, 91, 123, 124],
[21, 66, 73, 98, 99, 120],
[59, 73, 84, 90, 91, 92, 97, 123, 124],
[10, 78, 79, 80],
[77, 86, 88],
[77, 81, 82, 86, 88],
[77, 86, 88],
[6, 7, 8, 9, 79, 82],
[79, 81, 87, 89],
[84, 85],
[76, 83, 85, 90, 124],
[83, 84, 90, 91, 92],
[10, 78, 79, 80],
[82, 88, 89],
[10, 78, 79, 80, 87],
[6, 7, 8, 9, 82, 87],
[76, 84, 85, 123, 124],
[74, 76, 85, 123, 124],
[76, 85, 123, 124],
[22, 23, 59, 98, 99, 119, 120, 121, 122],
[22, 23, 59, 97, 98, 99, 124],
[22, 23, 96],
[19, 59, 95, 97, 98, 99],
[6, 7, 8, 9, 33, 59, 76, 94, 96, 120, 123, 133],
[75, 93, 94, 96, 119, 122],
[75, 93, 94, 96, 119, 122],
[14, 33, 34, 59],
[33, 59],
[33, 63, 65, 69],
[33, 50, 137],
[1, 2, 4, 10, 105],
[1, 104],
[56, 57],
[24, 25, 26, 116],
[1],
[1, 2, 4],
[1],
[1, 2, 4],
[1],
[10],
[10],
[10],
[10, 107],
[10],
[6, 7, 8, 9, 10],
[6, 7, 8, 9, 93, 98, 99, 120],
[6, 20, 57, 59, 75, 93, 97, 119],
[59, 93],
[93, 98, 99],
[20, 59, 74, 76, 90, 91, 92, 97, 124, 131, 132],
[21, 74, 76, 84, 90, 91, 92, 94, 123, 132, 133],
[63, 65, 69],
[127, 128],
[126, 128, 130],
[59, 126, 127, 139],
[63, 64],
[63, 64, 127, 139],
[21, 123],
[123, 124],
[59, 97, 124],
[57, 58, 66],
[20, 21],
[50, 53, 137],
[103, 136],
[50, 53],
[50, 53, 128, 130],
[50, 53, 64]
];


var coords1 = [
[0.7773052600869756,0.9545923537760372],
[0.7580562758133786,0.8265200732150304],
[0.9383644916261393,0.81184898898063],
[0.8073466947601575,0.5488347476266402],
[0.21282785587738662,0.9598976742709773],
[0.3067957820793672,0.7150279340526002],
[0.9871931100478113,0.6464028278389844],
[0.7259749025602591,0.8041690371425272],
[0.7967720925771797,0.07082379796842853],
[0.7414736021484702,0.9146244851075929],
[0.7566850885120051,0.6023013226853722],
[0.7421665072775196,0.196260343278434],
[0.5096813504255526,0.8908802663582278],
[0.633215995710104,0.7263966798778507],
[0.9075599851685487,0.20947806723514062],
[0.7264880407873524,0.532426359172135],
[0.02171483087480164,0.273278806460191],
[0.08528117355012532,0.9003846302490945],
[0.6884221153294494,0.453812376797619],
[0.7419841803846583,0.42426729922501294],
[0.27092642533059497,0.27306835918077677],
[0.9994989630714048,0.1723811133298423],
[0.621244347173542,0.8575698624501826],
[0.06131914779475278,0.13781821329628263],
[0.3478221250413318,0.8873620747631819],
[0.09001239257423532,0.9672203081329263],
[0.5599970146054996,0.9703869226710651],
[0.11772506361683566,0.7058701901622038],
[0.5066437922140441,0.38831965178622574],
[0.6427051156417818,0.7913626495108437],
[0.3532125002001987,0.5853010440125535],
[0.07729004158187625,0.5193613781222035],
[0.39709960789608,0.016360508941578145],
[0.7963430482294718,0.5075602894686408],
[0.7285015509940895,0.39222435651872534],
[0.8653286712096977,0.3050211630679738],
[0.9192038144743346,0.0007012660654110991],
[0.024857512268680493,0.5373691990425775],
[0.946391044902853,0.35217012555272076],
[0.857083493394345,0.18753119618539893],
[0.4966937994122351,0.31772328841032027],
[0.3232689484445128,0.2645123303528123],
[0.7890221888874818,0.6064516385274601],
[0.3633084370463915,0.8883825713652076],
[0.10916050039927017,0.8569038080796292],
[0.537851367668267,0.9446949526773292],
[0.0465680898868841,0.7658109954503001],
[0.6810563065773863,0.6192551799216539],
[0.20313954580133076,0.9472234663446393],
[0.16540383368973988,0.9289821637711462],
[0.27246981965225303,0.7322796673536893],
[0.0878598466604692,0.85352701406081],
[0.9712910895971913,0.5660427449293706],
[0.1339944945719338,0.6716028569702004],
[0.2231257784839984,0.734184403443837],
[0.34267936150140876,0.514856271227011],
[0.05465160009320047,0.8771886149171639],
[0.1800535635070475,0.9385928208347023],
[0.6497372947726638,0.9899233186024998],
[0.13636833142589166,0.9485140057862096],
[0.7986767423838379,0.9005522542525788],
[0.8216648067537535,0.5715295852238662],
[0.37992812755240957,0.8266208323478765],
[0.7930734724960875,0.7399813709577607],
[0.9896630696948967,0.5773143563403369],
[0.892037575505958,0.3906837792995743],
[0.9423586658110983,0.6369762672931787],
[0.3562837881541556,0.9816678778358925],
[0.8462039795040175,0.08974626152446308],
[0.3548508382203337,0.3098636881859509],
[0.407558499750742,0.239512932643843],
[0.5154107617939296,0.9110813548862939],
[0.3672670371749276,0.9613282983779199],
[0.9573438600791802,0.6368959695218788],
[0.10603240748464948,0.44978496946380875],
[0.36289455970011963,0.10058488998818671],
[0.52819916716802,0.7530963859994855],
[0.3560223713694255,0.267466768430231],
[0.05247486484957231,0.14505975516803304],
[0.9187913851230953,0.8389568444450528],
[0.3589568613471079,0.7073660158581421],
[0.9484993350375093,0.004707131042700707],
[0.05310738016247796,0.8675818232402186],
[0.6030104426246583,0.26446397462483073],
[0.35879987581426076,0.7091469382340652],
[0.5655364387610122,0.7141676636528729],
[0.22611321507397086,0.5380994113831612],
[0.6096592155237512,0.26810006119282703],
[0.5076634107513343,0.4832374746349606],
[0.2570607343469611,0.7765252574782753],
[0.7255577141086551,0.831955512780576],
[0.6181045712310176,0.12229923416490851],
[0.5128164301653011,0.9523238464094015],
[0.20701363889826152,0.5265503236910636],
[0.914324205433612,0.6382722629803081],
[0.8861333931225694,0.24210375374024418],
[0.8418189327389607,0.491415094451247],
[0.13814086144240223,0.5325597332660608],
[0.6374751367714071,0.08881571788687626],
[0.34320102739989555,0.3623712200876037],
[0.260100994982444,0.5628746218447171],
[0.907733348627805,0.3159822414703599],
[0.4729823775415123,0.6888643026615284],
[0.9599861188579855,0.704884999394795],
[0.32097519356784177,0.48418600748817475],
[0.5905079538704325,0.8714814427094411],
[0.6920328108167606,0.672196955487899],
[0.48418848533741277,0.9484321052055329],
[0.3734617040697652,0.14895445642271654],
[0.3436145998090452,0.06113487409391838],
[0.2726948399191591,0.3066793703100352],
[0.1921925817120207,0.12260477283094962],
[0.6062693248476232,0.16758736161900578],
[0.35563515631981346,0.8523008431616093],
[0.5130380403364978,0.270248903094753],
[0.035533658850134486,0.6991413855832411],
[0.31449305050880016,0.5960980033885477],
[0.7242517999612368,0.5134607118148544],
[0.5696870888598926,0.21209265521354692],
[0.25449119821622235,0.3969496576821996],
[0.15091753103969308,0.05186072666112662],
[0.0283540695201423,0.26662865945635406],
[0.07294289101210394,0.23168425896829747],
[0.20108593748864712,0.05930900904618097],
[0.26591747639675756,0.49956979829244896],
[0.28760080892389506,0.21329331437577337],
[0.15244619186860398,0.6876762665767102],
[0.16470870243058133,0.9521010413836701],
[0.5484131974847055,0.7094843138344666],
[0.11351372524801007,0.8500683834749865],
[0.17940043354682444,0.9545592070476161],
[0.36377459977103555,0.6818739212807661],
[0.7354801073216377,0.2720934559488728],
[0.25032409745250295,0.7220567154770408],
[0.34104283876400454,0.6036717244940992],
[0.8882159211913685,0.7930678962409778],
[0.3364947430108156,0.5027916569165507],
[0.8843325623047757,0.4182117031208965],
[0.5971419893657735,0.9879895519647723],
[0.6869396920844475,0.2022062991532534],
[0.9550163039879287,0.6798314348292616]
];</script>
<script>//make the attribute parser



var ELEM = function(nname,inner,attr,style){
    var e = document.createElement(nname);
    if(inner)e.innerHTML = inner;
    if(attr){
        var attrs = attr.split(";").map((at)=>{
            at = at.split(":");
            if(at.length !== 2)return false;
            e.setAttribute(at[0],at[1]);
        });
    }
    if(style)e.style = style;
    this.e = e;

    this.add = function(nname,inner,attr,style){
        if(typeof nname === "string"){
            var eelem = new ELEM(nname,inner,attr,style);
            this.e.appendChild(eelem.e);
            return eelem;
        }else{
            this.e.appendChild(nname.e);
            return nname;
        }
    };
    this.attr = function(a,b){
        this.e.setAttribute(a,b);
    };
};

var body = (new function(){
    this.e = document.body;
    this.add = function(nname,inner,attr,style){
        if(typeof nname === "string"){
            var eelem = new ELEM(nname,inner,attr,style);
            this.e.appendChild(eelem.e);
            return eelem;
        }else{
            this.e.appendChild(nname.e);
            return nname;
        }
    };
}());
</script>
<script>var TwoDWorld = function(){//might make a 3d version soon
    //id gen
    var IDGENNOW = 0;
    var IDGEN = function(){
        return IDGENNOW++;
    };



    //obj methods
    //del
    //addObj
    //createObj
    //renderObj
    //updateChildren
    var del = function(){
        delete this.parent.children[this.id];
        delete this.that.objs[this.id];
        delete this.that.objsByTypes[this.type][this.id];
        //do the same with the children
        //delete the children as well
        for(var key in this.children){
            this.children[key].del();
        }
    };
    var addObj = function(o){
        if(o.parent)delete o.parent.children[o.id];
        o.parent = this;
        this.children[o.id] = o;
    };
    var createObj = function(o){
        var p = Object.create(objproto);
        for(var key in o){
            p[key] = o[key];
        }
        p.children = {};//get objects out of the way
        p.id = IDGEN();
        p.parent = this;
        this.children[p.id] = p;
        this.that.objs[p.id] = p;
        this.that.objsByTypes[p.type][p.id] = p;
        return p;
    };
    var renderObj = function(renderData){
        //"this" is the object
        //can access object by using this
        var type = this.that.types[this.type];
        type.render(this,renderData);
    };
    //sideeffect:updates children's coordinates
    var updateChildren = function(callback){
        this.updateXYA();
        callback(this);
        for(var key in this.children){
            this.children[key].updateChildren(callback);
        }
    };
    var updateXYA = function(){
        //console.log(this);
        this.a = this.parent.a + this.la;
        //parent because obj xy will be the center of obj rotation
        var dx = Math.cos(this.parent.a)*this.lx - Math.sin(this.parent.a)*this.ly;
        var dy = Math.sin(this.parent.a)*this.lx + Math.cos(this.parent.a)*this.ly;
        this.x = this.parent.x + dx;
        this.y = this.parent.y + dy;
    };

    var objproto = {
        x:0,
        y:0,
        a:0,
        lx:0,
        ly:0,
        la:0,
        w:0,
        h:0,
        r:0,
        cx:0,
        cy:0,
        lx1:0,
        ly1:0,
        that:this,
        polygon:null,
        root:false,
        parent:null,
        //children:{},
        addObj:addObj,
        createObj:createObj,
        del:del,
        render:renderObj,
        type:"initial",
        updateChildren:updateChildren,
        updateXYA:updateXYA,
        fillStyle:"#000000",
        strokeStyle:"#000000"
    };

    //interface to the outside world
    this.objs = {};
    this.root = Object.create(objproto);
    this.root.root = true;
    this.root.parent = this.root;
    this.root.children = {};
    this.types = {
        initial:{
            render:function(){}
        }
    };
    this.objsByTypes = {
        initial:[]
    };

    this.render = function(renderData){
        //console.log(this.objs);
        this.root.updateChildren(a=>{});
        renderData.ctx.clearRect(0,0,renderData.w,renderData.h);
        //may need additional improvements:
        //see if the object is intersecting with the window before checking
        for(var key in this.objs){
            //if(this.objs[key].onrender)this.objs[key].onrender;
            this.objs[key].render(renderData);
        }
    };
    this.addType = function(name,t){
        this.types[name] = t || function(){};//renfer or do nothing
        this.objsByTypes[name] = {};
    };
};



/*
//event code start

var canvasEvents = {};

//ONLY SUPPORTS CIRCULAR COLLISION
var event = function(obj,type,callback){
    if(!(type in canvasEvents)){//unknown type of event
        canvasEvents[type] = {};//list of objects
        //ideally doubly inked list
        canvas.addEventListener(type,function(e){
            //type is defined in this scope lol
            var evobjs = canvasEvents[type];
            for(var key in evobjs){
                var evobj = evobjs[key];
                var obj = evobj[0];
                var callback = evobj[1];

                if(objIntersection(e,rd1,obj)){//if intersecting
                    //trigger event
                    callback.bind(obj)();
                    break;//two canvasEvents can't be triggered at the same time
                };
            }
        });
    }
    canvasEvents[type][obj.id] = [obj,callback];
};

//event code end
*/






</script>
<script>//require ./2dworld.js


var canvas = document.createElement("canvas");
canvas.width = 1000;
canvas.height = 1000;
document.body.appendChild(canvas);
var rd1 = {
    canvas:canvas,
    ctx:canvas.getContext("2d"),
    w:canvas.width,
    h:canvas.height,
    x:0,//center coordinates
    y:0,
    a:0,
    zoom:50
};


var rotateX = function(x,y,a){
    return Math.cos(a)*x - Math.sin(a)*y;
};

var rotateY = function(x,y,a){
    return Math.sin(a)*x + Math.cos(a)*y;
};

var xyRenderData = function(x,y,renderData){
    var x1 = (x-renderData.x)*renderData.zoom+renderData.w/2;
    var y1 = (y-renderData.y)*renderData.zoom+renderData.h/2;
    var x11 = rotateX(x1,y1,renderData.a);
    var y11 = rotateY(x1,y1,renderData.a);
    return [x11,y11];
};

var renderDataXY = function(x,y,renderData){//exact inverse
    var x1 = rotateX(x,y,-renderData.a);
    var y1 = rotateY(x,y,-renderData.a);
    var x11 = (x1-renderData.w/2)/renderData.zoom+renderData.x;
    var y11 = (y1-renderData.h/2)/renderData.zoom+renderData.y;
    return [x11,y11];
};


var world = new TwoDWorld();
world.addType(
    "circle",
    {
        render:function(obj,renderData){
            //console.log(obj,renderData);
            var canvas = renderData.canvas;
            var ctx = renderData.ctx;
            var xy = xyRenderData(obj.x,obj.y,renderData);
            //console.log(xy[0],xy[1],obj.r,0,6.28);
            ctx.beginPath();
            ctx.arc(xy[0],xy[1],obj.r*renderData.zoom,0,6.28);
            ctx.closePath();
            ctx.fillStyle = obj.fillStyle;
            ctx.strokeStyle = obj.strokeStyle;
            ctx.fill();
            ctx.stroke();
        }
    }
);

world.addType(
    "collider",
    {
        render:function(){}//don't render
    }
);

world.addType(
    "line",
    //requires:
    //.lx
    //.ly
    //.lx1
    //.ly1
    //.a
    {
        render:function(obj,renderData){
            //console.log(obj,renderData);
            var canvas = renderData.canvas;
            var ctx = renderData.ctx;
            //tno center coord

            ctx.beginPath();
            var xy;
            xy = xyRenderData(obj.x,obj.y,renderData);
            ctx.moveTo(xy[0],xy[1]);
            var ldx = obj.lx1-obj.lx;
            var ldy = obj.ly1-obj.ly;
            var x1 = obj.x + rotateX(ldx,ldy,obj.a);
            var y1 = obj.y + rotateY(ldx,ldy,obj.a);
            xy = xyRenderData(x1,y1,renderData);
            ctx.lineTo(xy[0],xy[1]);
            ctx.closePath();

            ctx.fillStyle = obj.fillStyle;
            ctx.strokeStyle = obj.strokeStyle;
            ctx.fill();
            ctx.stroke();
        }
    }
);


/*
var animate = function(t){
    world.render(rd1);
    window.requestAnimationFrame(animate);
};
window.requestAnimationFrame(animate);
*/
</script>
<script>

//event code start

var canvasEvents = {};

var event = function(obj,type,callback){
    if(!(type in canvasEvents)){//unknown type of event
        canvasEvents[type] = {};//list of objects
        //ideally doubly inked list
        canvas.addEventListener(type,function(e){
            //type is defined in this scope lol
            var evobjs = canvasEvents[type];
            for(var key in evobjs){
                var evobj = evobjs[key];
                var obj = evobj[0];
                var callback = evobj[1];

                if(objIntersection(e,rd1,obj)){//if intersecting
                    //trigger event
                    (callback.bind(obj))(e);
                    break;//two canvasEvents can't be triggered at the same time
                };
            }
        });
    }
    canvasEvents[type][obj.id] = [obj,callback];
};

var objIntersection = function(e,renderData,obj){
    var cx = e.offsetX;
    var cy = e.offsetY;
    var oxy = xyRenderData(obj.x,obj.y,renderData);
    var ox = oxy[0];
    var oy = oxy[1];
    var or = obj.r*renderData.zoom;
    var dist2 = (ox-cx)**2+(oy-cy)**2;
    if(or**2 > dist2){//intersecting
        return true;
    }
    return false;
};



//event code end
//event();



/*
var aqueue = new AnimationQueue();
aqueue.add(function(cut){
    rect.la += 0.1;
    world.render(rd1);
});*/</script>
<script>var thash = function(a,b,len){
    if(a < b)return a*len+b;
    return b*len+a;
};

var tdecode = function(hash,len){
    hash = parseInt(hash);
    var a = Math.floor(hash/len);
    var b = hash-a*len;
    return [a,b];
}</script>
<script>//require ./data1.js
//require /lib/htmlgen.js
//require ./linecircle.js
//require ./event.js
//require /lib/thash.js


//repel from the corners

graphdata1;
coords1;
var vels1 = [];
for(var i = 0; i < coords1.length; i++){
    vels1[i] = [0,0];
}


var mouseDownActivated = false;
var objFollow = null;
var objFollowLX = 0;
var objFollowLY = 0;
var dragDX = 0;
var dragDY = 0;


var registerEvent = function(circle,coords,vels,i){
    event(circle,"mousedown",function(e){
        console.log(this);
        console.log(e);
        mouseDownActivated = true;
        objFollow = this;
        var xy = renderDataXY(e.offsetX-rd1.w/2,e.offsetY-rd1.h/2,rd1);//offset is the coordinates
        var dragDXO = xy[0] - objFollow.x;
        var dragDYO = xy[1] - objFollow.y;
        var deltaxy = xyRenderData(dragDXO,dragDYO,rd1);
        dragDX = deltaxy[0];
        dragDY = deltaxy[1];
        var x = e.offsetX-dragDX;
        var y = e.offsetY-dragDY;
        var xy = renderDataXY(x,y,rd1);
        var coords = objFollow.coords;
        var coord = coords[objFollow.coordsidx];
        objFollowLX = xy[0];
        objFollowLY = xy[1];
    });
};

document.addEventListener("mouseup",function(e){
    mouseDownActivated = false;
});
document.addEventListener("mousemove",function(e){
    if(mouseDownActivated){
        console.log(objFollow);
        var x = e.offsetX-dragDX;
        var y = e.offsetY-dragDY;
        var xy = renderDataXY(x,y,rd1);
        var coords = objFollow.coords;
        var coord = coords[objFollow.coordsidx];
        objFollowLX = xy[0];
        objFollowLY = xy[1];
    }
});




var AnimateGraph = function(graph,coords,vels){

    //preparing the world based on the graph
    var circles = [];
    var edges = {};
    console.log(edges);
    for(var i = 0; i < graph.length; i++){
        var circ = world.root.createObj({
            type:"circle",
            r:2/50,
            lx:coords[i][0],
            ly:coords[i][1],
            coords:coords,
            coordsidx:i
        });
        circles[i] = circ;

        //event
        registerEvent(circ,coords,vels,i);


        var node = graph[i];
        for(var j = 0; j < node.length; j++){
            var lineId = thash(i,node[j],graph.length);
            if(!(lineId in edges)){
                var line = world.root.createObj({
                    type:"line",
                    lx:coords[i][0],
                    ly:coords[i][1],
                    lx1:coords[node[j]][0],
                    ly1:coords[node[j]][1],
                    strokeStyle:"#0002"
                });
                edges[lineId] = line;
            }
        }
    }

    //var graphs = separate(graph);


    var render = function(){
        //console.log(circles);
        //console.log(edges);
        var zoom = 50;
        for(var i = 0; i < graph.length; i++){
            var node = graph[i];
            var c1 = coords[i];
            circles[i].lx = c1[0];
            circles[i].ly = c1[1];
        }
        for(var key in edges){
            var ab = tdecode(key,graph.length);
            var a = ab[0];
            var b = ab[1];
            edges[key].lx = coords[a][0];
            edges[key].ly = coords[a][1];
            edges[key].lx1 = coords[b][0];
            edges[key].ly1 = coords[b][1];
        }
        world.render(rd1);
    };

    var st = 0;

    var animate = function(t){
        if(st === 0)st = t;
        var dt = t - st;

        if(mouseDownActivated){
            coords[objFollow.coordsidx][0] = objFollowLX;
            coords[objFollow.coordsidx][1] = objFollowLY;
        }
        fdgd(graph,coords,vels);

        //render
        render();
        window.requestAnimationFrame(animate);
    };

    var start = function(){


    }

    window.requestAnimationFrame(animate);

};



var fdgd = function(graph,coords,vel){//interval 1
    //repeat this many times. Just do one iteration. Interchangeable
    for(var i = 0; i < graph.length; i++){
        if(mouseDownActivated && i === objFollow.coordsidx)continue;
        var dfx = 0;
        var dfy = 0;

        for(var j = 0; j < graph.length; j++){
            if(i !== j){
                var dx = coords[j][0]-coords[i][0];
                var dy = coords[j][1]-coords[i][1];
                var dd = (dx**2+dy**2)**0.5;
                var df = interconnectionForce(dx,dy,dd,graph.length);
                dfx += df*dx/dd;
                dfy += df*dy/dd;
            }
        }
        var node = graph[i];
        for(var j = 0; j < node.length; j++){
            if(i !== j){
                var dx = coords[node[j]][0]-coords[i][0];
                var dy = coords[node[j]][1]-coords[i][1];
                var dd = (dx**2+dy**2)**0.5;
                var df = connectionForce(dx,dy,dd,graph.length,node.length);
                dfx += df*dx/dd*5;
                dfy += df*dy/dd*5;
            }
        }
        //adding the forces from the "four walls"
        var wdist = 8;
        if(coords[i][0] < -wdist){
            dfx = Math.abs(dfx);
            //dfx += (-wdist-coords[i][0])**1;
        }else if(coords[i][0] > wdist){
            dfx = -Math.abs(dfx);
            //dfx += (wdist-coords[i][0])**1;
        }
        if(coords[i][1] < -wdist){
            dfy = Math.abs(dfy);
            //dfy += (-wdist-coords[i][1])**1;
        }else if(coords[i][1] > wdist){
            dfy = -Math.abs(dfy);
            //dfy += (wdist-coords[i][1])**1;
        }
        //dfx += -(2**(0.5*(coords[i][0]+5)))/1000000;//force from left
        //dfx += (2**(0.5*(5-coords[i][0])))/1000000;//force from right
        //dfy += -(2**(0.5*(coords[i][1]+5)))/1000000;//force from top
        //dfy += (2**(0.5*(5-coords[i][1])))/1000000;//force from bottom
        var ft = coords[i][0];//distance from right
        //console.log(dfx,dfy);
        vel[i][0] *= 0.8;
        vel[i][1] *= 0.8;
        vel[i][0] += dfx;
        vel[i][1] += dfy;
        //if(Math.abs(vel[i][0]) < 0.004)vel[i][0] = 0;
        //if(Math.abs(vel[i][1]) < 0.004)vel[i][1] = 0;
        coords[i][0] += vel[i][0];
        coords[i][1] += vel[i][1];
    }
    return true;//mutates the objects that were passed
    //normalize the coordinates
    /*
    var xsum = 0;
    var ysum = 0;
    for(var i = 0; i < coords.length; i++){
        //xsum += coords[i][0];
        //ysum += coords[i][1];
    }
    var xsum = xsum/coords.length;
    var ysum = ysum/coords.length;
    for(var i = 0; i < coords.length; i++){
        //coords[0] -= xsum;
        //coords[1] -= ysum;
    }*/
};

var interconnectionForce = function(dx,dy,dd,glen){
    //return 0;
    return -1/(dd*dd+0.01)/glen/5;
};

var connectionForce = function(dx,dy,dd,glen,nlen){
    //return 0;
    return -(1-dd)/(nlen/nlen)/50;
};





var animation = new AnimateGraph(graphdata1,coords1,vels1);
//animation.start();





</script>

</body>